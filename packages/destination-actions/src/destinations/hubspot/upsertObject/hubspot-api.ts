import { RequestClient, ModifiedResponse, IntegrationError } from '@segment/actions-core'
import { HubSpotError } from '../errors'
import { HUBSPOT_BASE_URL } from '../properties'
import { BATCH_SIZE, SUPPORTED_HUBSPOT_OBJECT_TYPES } from './constants'
import type { Payload } from './generated-types'

interface ObjectSchema {
    labels: { singular: string; plural: string }
    fullyQualifiedName: string
}

interface GetSchemasResponse {
    results: ObjectSchema[]
}

enum AssociationCategory {
    HUBSPOT_DEFINED = 'HUBSPOT_DEFINED',
    USER_DEFINED = 'USER_DEFINED',
    INTEGRATOR_DEFINED = 'INTEGRATOR_DEFINED'
}

interface BatchReadRequestBody {
    properties: string[]
    idProperty: string
    inputs: Array<{ id: string }>
}

interface BatchReadResponse {
    status: string
    results: BatchReadResponseItem[]
}

interface BatchReadResponseItem {
    id: string
    properties: Record<string, string | null>
}

interface BatchRequestBody {
    inputs: BatchRequestBodyItem[];
}
interface BatchRequestBodyItem {
    properties: {
        [key: string]: string | number | boolean | undefined;
    };
    id?: string;
}

interface AssociationType {
    associationCategory: AssociationCategory
    associationTypeId: string
}

interface BatchAssociationsRequestBody {
    inputs: {
        types: AssociationType[];
        from: {
            id: string;
        };
        to: {
            id: string;
        };
    }[];
}
export class HubspotClient {
    request: RequestClient

    constructor(request: RequestClient) {
        this.request = request
    }

    async getIdFields(objectType: string) {

        interface ObjectField {
            label: string
            name: string
            hasUniqueValue: boolean
        }
        
        interface ObjectFieldsResponse {
            data: {
            results: ObjectField[]
            }
        }

        const fields: ObjectFieldsResponse = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}`, {
            method: 'GET',
            skipResponseCloning: true
        })
        
        return {
            choices: [
                {
                    label: 'Hubspot Record ID (updates only)',
                    value: 'hs_object_id'
                },
                // hs_unique_creation_key is a unique identifier that is automatically generated by HubSpot. It is readonly so should not be included in the dynamic list
                ...fields.data.results
                .filter((field: ObjectField) => field.hasUniqueValue && field.name != 'hs_unique_creation_key')
                .map((field: ObjectField) => {
                    return {
                    label: field.label,
                    value: field.name
                    }
                })
            ]
        }
    }

    async getObjectTypes() {
        const defaultChoices = SUPPORTED_HUBSPOT_OBJECT_TYPES
       
        try {
            const response = await this.request<GetSchemasResponse>(`${HUBSPOT_BASE_URL}/crm/v3/schemas?archived=false`, {
                method: 'GET',
                skipResponseCloning: true
            })
            const choices = response.data.results
                .map((schema) => ({
                    label: `${schema.labels.plural} (Custom)`,
                    value: schema.fullyQualifiedName
                }))
            return {
                choices: [...choices, ...defaultChoices]
            }
        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
                    code: (err as HubSpotError)?.response?.status + '' ?? '500'
                }
            }
        }
    }

    async getAssociationLabel(objectType: string, toObjectType: string) {
        interface AssociationLabel {
            category: AssociationCategory
            typeId: number
            label: string
        }
        interface GetAssociationLabelResponse {
            results: AssociationLabel[]
        }
        
        try {
            const response = await this.request<GetAssociationLabelResponse>(
                `${HUBSPOT_BASE_URL}/crm/v4/associations/${objectType}/${toObjectType}/labels`, {
                    method: 'GET',
                    skipResponseCloning: true
                }
            )
            const choices = response?.data?.results?.map((res) => ({
                label: !res.label ? `${objectType} to ${toObjectType} (Type ${res.typeId})` : `${objectType} to ${toObjectType} ${res.label}`,
                value: `${res.category}:${res.typeId}`
            }))

            return {
                choices
            }
        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
                    code: (err as HubSpotError)?.response?.data?.category ?? 'Unknown code'
                }
            }
        }
    }

    getAssociationType(associationLabel: string): AssociationType {
        const [associationCategory, associationTypeId] = associationLabel.split(':');
        return { associationCategory, associationTypeId } as AssociationType
    }

    async batchObjectRequest(
        action: 'update' | 'create' | 'read', 
        objectType: string,
        data: BatchReadRequestBody | BatchRequestBody
    ) {        
        return this.request<BatchReadResponse>(`${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}/batch/${action}`, {
            method: 'POST',
            json: data
        });
    }

    async batchAssociationsRequest(body: BatchAssociationsRequestBody, objectType: string, toObjectType: string){
        return this.request<BatchReadResponse>(`${HUBSPOT_BASE_URL}/crm/v4/associations/${objectType}/${toObjectType}/batch/create`, {
            method: 'POST',
            json: body
        })
    }

    async ensureAssociations(payloads: Payload[]) {
        const [{objectType, toObjectType, associationLabel}] = payloads
        
        if(!objectType || !toObjectType || !associationLabel){
            throw new IntegrationError('Missing required Association fields. Associations require "To Object Type", "To ID Field Name" and "Association Label" fields to be set.','REQUIRED_ASSOCIATION_FIELDS_MISSING',400)
        }
        
        const {associationCategory, associationTypeId} = this.getAssociationType(associationLabel)

        const bodies: BatchAssociationsRequestBody[] = this.chunkArray(payloads
            .filter(p => p.recordID && p.toRecordID)
            .map(p => { 
                return {
                    types: [
                        {
                            associationCategory,
                            associationTypeId
                        }
                    ],
                    from: {
                        id: p.recordID as string
                    },
                    to: {
                        id: p.toRecordID as string
                    }
                }
            }))
            .map(chunk => {
                return {
                    inputs: chunk
                }
            })
    
        const requests:Promise<ModifiedResponse<BatchReadResponse>>[] = []
             
        bodies.forEach((body) => {
            requests.push(this.batchAssociationsRequest(body, objectType, toObjectType))
        })
        console.log(`Associations: ${requests.length}`)
        return requests.length>0 ? await Promise.all(requests) : null
    }

    chunkArray<T>(array: T[]): T[][]{
        return Array.from({ length: Math.ceil(array.length / BATCH_SIZE) }, (_, index) =>
            array.slice(index * BATCH_SIZE, index * BATCH_SIZE + BATCH_SIZE)
        )
    }

    populateChunks(requestBodies: BatchRequestBody[], itemPayload: BatchRequestBodyItem) {
        const currenRequestBody = requestBodies[requestBodies.length - 1]?.inputs;
        if (!currenRequestBody || currenRequestBody.length === BATCH_SIZE) {
            requestBodies.push({ inputs: [itemPayload] });
        } else {
            currenRequestBody.push(itemPayload);
        }
    };

    async ensureObjects(payloads: Payload[], isAssociationObject = false) {

        const [{insertType, associationLabel }] = payloads
        const idFieldName = isAssociationObject ? payloads[0].toIdFieldName : payloads[0].idFieldName
        const objectType = isAssociationObject ? payloads[0].toObjectType : payloads[0].objectType
        const idFieldValueFieldName = isAssociationObject ? 'toIdFieldValue' : 'idFieldValue'
        const recordIdFieldName = isAssociationObject ? 'toRecordID' : 'recordID'

        if( isAssociationObject && (!objectType || !idFieldName || !associationLabel) || (!objectType || !idFieldName) ){
            throw new IntegrationError('Missing required Association fields. Associations require "To Object Type", "To ID Field Name" and "Association Label" fields to be set.','REQUIRED_ASSOCIATION_FIELDS_MISSING',400)
        }

        const requests = []

        for (let i = 0; i < payloads.length; i += BATCH_SIZE) {
            const batch = payloads.slice(i, i + BATCH_SIZE);
            requests.push(
            this.batchObjectRequest('read', objectType, {
                properties: [idFieldName],
                idProperty: idFieldName,
                inputs: batch.map(p => { return {id: p[idFieldValueFieldName]}})             
            } as BatchReadRequestBody)
            )
        }
        
        const readResponses = await Promise.all(requests);
        
        readResponses.forEach((response) => {      
            response.data.results.forEach(result => {
                payloads
                    .filter(payload => payload[idFieldValueFieldName] == result.properties[idFieldName] as string)
                    .forEach(payload => payload[recordIdFieldName] = result.id )
            })
        })

        const updateRequestBodies: BatchRequestBody[] = []
        const createRequestBodies: BatchRequestBody[] = []
        const createRequests:Promise<ModifiedResponse<BatchReadResponse>>[] = []
        const updateRequests:Promise<ModifiedResponse<BatchReadResponse>>[] = []

        payloads.forEach((payload) => {
            const { stringProperties, numericProperties, booleanProperties, dateProperties } = payload
            const itemPayload: { id?: string | undefined; properties: { [key: string]: string | number | boolean | undefined } } = {
                id: payload[recordIdFieldName] ?? undefined,
                properties: {
                    ...stringProperties, 
                    ...numericProperties, 
                    ...booleanProperties, 
                    ...dateProperties,
                    [idFieldName]: payload[idFieldValueFieldName]
                } as BatchRequestBodyItem['properties']
            } as BatchRequestBodyItem
            if(['update', 'upsert'].includes(insertType) && itemPayload.id){
                this.populateChunks(updateRequestBodies, itemPayload)
            }
            if(['create', 'upsert'].includes(insertType) && !itemPayload.id){
                this.populateChunks(createRequestBodies, itemPayload)
            }
        })
        
        updateRequestBodies.forEach((updateRequestBody) => {
            updateRequests.push(this.batchObjectRequest('update', objectType, updateRequestBody))
        })

        createRequestBodies.forEach((createRequestBody) => {
            createRequests.push(this.batchObjectRequest('create', objectType, createRequestBody))
        })
        const writeRequests = [...updateRequests, ...createRequests]
        console.log(`${isAssociationObject} . Number of createRequests requests: ${createRequests.length}`)
        console.log(`${isAssociationObject} . Number of updateRequests requests: ${updateRequests.length}`)
        return writeRequests.length>0 ? await Promise.all([...updateRequests, ...createRequests]) : null
    }
}
