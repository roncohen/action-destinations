import { RequestClient, ModifiedResponse } from '@segment/actions-core'
import { HubSpotError } from '../errors'
import { HUBSPOT_BASE_URL } from '../properties'

interface ResponseInfo {
    id: string
    properties: Record<string, string>
}
interface SearchResponse {
    total: number
    results: ResponseInfo[]
}

enum AssociationCategory {
    HUBSPOT_DEFINED = 'HUBSPOT_DEFINED',
    USER_DEFINED = 'USER_DEFINED',
    INTEGRATOR_DEFINED = 'INTEGRATOR_DEFINED'
}
export interface AssociationType {
    associationCategory: AssociationCategory
    associationTypeId: number
}

interface UpsertRecordResponse extends ResponseInfo {}

export class HubspotClient {
    request: RequestClient

    constructor(request: RequestClient) {
        this.request = request
    }

    async getIdFields(objectType: string) {

        interface ObjectField {
            label: string
            name: string
            hasUniqueValue: boolean
        }
        
        interface ObjectFieldsResponse {
            data: {
            results: ObjectField[]
            }
        }

        const fields: ObjectFieldsResponse = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}`, {
            method: 'GET',
            skipResponseCloning: true
        })
        
        return {
            choices: [
                {
                    label: 'Hubspot Record ID (updates only)',
                    value: 'hs_object_id'
                },
                // hs_unique_creation_key is a unique identifier that is automatically generated by HubSpot. It is readonly so should not be included in the dynamic list
                ...fields.data.results
                .filter((field: ObjectField) => field.hasUniqueValue && field.name != 'hs_unique_creation_key')
                .map((field: ObjectField) => {
                    return {
                    label: field.label,
                    value: field.name
                    }
                })
            ]
        }
    }

    async getObjectTypes() {
        interface ObjectSchema {
            labels: { singular: string; plural: string }
            fullyQualifiedName: string
        }
        
        interface GetSchemasResponse {
            results: ObjectSchema[]
        }

        const defaultChoices = [
        {
            label: 'Contact',
            value: 'contact'
        },
        {
            label: 'Company',
            value: 'company'
        },
        {
            label: 'Deal',
            value: 'deal'
        },
        {
            label: 'Ticket',
            value: 'ticket'
        }
        ]
        // API Doc - https://developers.hubspot.com/docs/api/crm/crm-custom-objects#endpoint?spec=GET-/crm/v3/schemas
        try {
        const response = await this.request<GetSchemasResponse>(`${HUBSPOT_BASE_URL}/crm/v3/schemas?archived=false`, {
            method: 'GET',
            skipResponseCloning: true
        })
        const choices = response.data.results
            .map((schema) => ({
            label: `${schema.labels.plural} (Custom)`,
            value: schema.fullyQualifiedName
            }))
        return {
            choices: [...choices, ...defaultChoices]
        }
        } catch (err) {
        return {
            choices: [],
            error: {
            message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
            code: (err as HubSpotError)?.response?.status + '' ?? '500'
            }
        }
        }
    }

    async getAssociationLabel(objectType: string, toObjectType: string) {
        
        interface AssociationLabel {
            category: AssociationCategory
            typeId: number
            label: string
        }
        interface GetAssociationLabelResponse {
            results: AssociationLabel[]
        }
        
        try {
            const response = await this.request<GetAssociationLabelResponse>(
                `${HUBSPOT_BASE_URL}/crm/v4/associations/${objectType}/${toObjectType}/labels`,
                {
                method: 'GET',
                skipResponseCloning: true
                }
        )
        const choices = response?.data?.results?.map((res) => ({
            label: !res.label ? `${objectType} to ${toObjectType} (Type ${res.typeId})` : `${objectType} to ${toObjectType} ${res.label}`,
            value: `${res.category}:${res.typeId}`
        }))
        return {
            choices
        }
        } catch (err) {
        return {
            choices: [],
            error: {
            message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
            code: (err as HubSpotError)?.response?.data?.category ?? 'Unknown code'
            }
        }
        }
    }

    async search( idFieldName: string, idFieldValue: string, objectType: string, responseProperties: string[], responseSortBy: string[]) {
        enum SearchFilterOperator {
            EQ = 'EQ'
        }
        interface SearchPayload {
            filterGroups: SearchFilterGroup[]
            properties?: string[]
            sorts?: string[]
            limit?: number
            after?: number
        }
        interface SearchFilterGroup {
            filters: SearchFilter[]
        }
        interface SearchFilter {
            propertyName: string
            operator: SearchFilterOperator
            value: unknown
        }

        const searchPayload: SearchPayload = {
            filterGroups: [{
                filters: [{
                    propertyName: idFieldName,
                    operator: SearchFilterOperator.EQ,
                    value: idFieldValue
                }]
            }],
            properties: [...responseProperties],
            sorts: [...responseSortBy]
        }

        return this.request<SearchResponse>(`${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}/search`, {
            method: 'POST',
            json: {
                ...searchPayload
            }
        })
    }

    async update(idFieldName: string, recordId: string,  objectType: string, properties: { [key: string]: unknown }, ) {
        const updateURL = `${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}/${recordId}?idProperty=${idFieldName}`
        return this.request<UpsertRecordResponse>(updateURL, {
            method: 'PATCH',
            json: {
                properties: properties
            }
        })
    }

    async create(objectType: string, properties: { [key: string]: unknown }, associationLabel?: string, toRecordId?: string) {
        interface CreateAssociation {
            to: {
              id: string
            }
            types: AssociationType[]
        }
        
        let associationObject = null

        if(toRecordId && associationLabel){
            associationObject = {
                to: {
                  id: toRecordId
                },
                types: this.getAssociationType(associationLabel)
            } as CreateAssociation
        }

        return this.request<UpsertRecordResponse>(`${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}`, {
          method: 'POST',
          json: {
            properties: properties,
            associations: associationObject
          }
        })
      }

    async getRecordID( idFieldName?: string, idFieldValue?: string, objectType?: string): Promise<string | undefined> {
        
        if(!idFieldName || !idFieldValue || !objectType) return undefined

        if(idFieldName === 'hs_object_id') return idFieldValue 
        
        let searchResponse: ModifiedResponse<SearchResponse> | null = null
        searchResponse = await this.search(idFieldName, idFieldValue, objectType, [], [])   
        if (!searchResponse?.data || searchResponse?.data?.total != 1) {
            return undefined
        }
        return searchResponse.data.results[0].id
    }

    async associate(recordId: string, toRecordId: string, associationLabel: string, objectType: string, toObjectType: string) {
        const association = this.getAssociationType(associationLabel)
        const associateURL = `${HUBSPOT_BASE_URL}/crm/v4/objects/${objectType}/${recordId}/associations/${toObjectType}/${toRecordId}`
        return this.request<UpsertRecordResponse>(associateURL, {
          method: 'PUT',
          json: association
        })
    }

    getAssociationType(associationLabel?: string): AssociationType[]{
        if(!associationLabel){
            return []
        }

        const associationType = associationLabel.split(':')
        
        return [{
          associationCategory: associationType[0] as AssociationCategory,
          associationTypeId: Number(associationType[1])
        }] as AssociationType[]
    }

    // async addCononicalIDsToBatchPayloads(payloads: ContactPayload[]): Promise<ContactPayload[]>{
        
    //     payloads.forEach(payload => payload.identifier_type = payload.identifier_type ?? 'email')

    //     const unique_identifier_types: string[] = Array.from(new Set(payloads.map(payload => payload.identifier_type as string))) ?? [];

    //     const requestPayloads: BatchContactReadRequestBody[] = []
    //     unique_identifier_types.forEach(identifier_type => {
    //         const requestPayload: BatchContactReadRequestBody = {
    //             properties: [...new Set([...['email', 'lifecyclestage'], ...[identifier_type]])],
    //             idProperty: identifier_type,
    //             inputs: payloads
    //                 .filter(payload => payload.identifier_type === identifier_type)
    //                 .map(payload => { return {id: payload.email}})             
    //         }
    //         requestPayloads.push(requestPayload)
    //     }) 

    //     const promises = requestPayloads.map(payload => this.batchRequest('read', payload));

    //     const responses = await Promise.all(promises);

    //     unique_identifier_types.forEach((identifier_type, index) => {
    //         responses[index].data.results.forEach((contactResponse) => {
    //             const canonical_id = contactResponse.id 
    //             const identifier_value = contactResponse.properties[identifier_type] as string
    //             payloads.filter(payload => payload.email == identifier_value).forEach(payload => payload.canonical_id = canonical_id);
    //         })
    //     });        
    //     return payloads
    // }
}
