import { RequestClient, ModifiedResponse } from '@segment/actions-core'
import { HubSpotError } from '../errors'
import { HUBSPOT_BASE_URL } from '../properties'
import { INSERT_TYPES, BATCH_SIZE } from './constants'
import type { Payload } from './generated-types'

interface ResponseInfo {
    id: string
    properties: Record<string, string>
}
interface SearchResponse {
    total: number
    results: ResponseInfo[]
}

enum AssociationCategory {
    HUBSPOT_DEFINED = 'HUBSPOT_DEFINED',
    USER_DEFINED = 'USER_DEFINED',
    INTEGRATOR_DEFINED = 'INTEGRATOR_DEFINED'
}

export interface BatchReadRequestBody {
    properties: string[]
    idProperty: string
    inputs: Array<{ id: string }>
}

export interface BatchReadResponse {
    status: string
    results: BatchReadResponseItem[]
}

interface BatchReadResponseItem {
    id: string
    properties: Record<string, string | null>
}

export interface BatchRequestBody {
    inputs: BatchRequestBodyItem[];
}
export interface BatchRequestBodyItem {
    properties: {
        [key: string]: string | number | boolean | undefined;
    };
    id?: string;
}

export interface AssociationType {
    associationCategory: AssociationCategory
    associationTypeId: number
}

interface UpsertRecordResponse extends ResponseInfo {}

export class HubspotClient {
    request: RequestClient

    constructor(request: RequestClient) {
        this.request = request
    }

    async getIdFields(objectType: string) {

        interface ObjectField {
            label: string
            name: string
            hasUniqueValue: boolean
        }
        
        interface ObjectFieldsResponse {
            data: {
            results: ObjectField[]
            }
        }

        const fields: ObjectFieldsResponse = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}`, {
            method: 'GET',
            skipResponseCloning: true
        })
        
        return {
            choices: [
                {
                    label: 'Hubspot Record ID (updates only)',
                    value: 'hs_object_id'
                },
                // hs_unique_creation_key is a unique identifier that is automatically generated by HubSpot. It is readonly so should not be included in the dynamic list
                ...fields.data.results
                .filter((field: ObjectField) => field.hasUniqueValue && field.name != 'hs_unique_creation_key')
                .map((field: ObjectField) => {
                    return {
                    label: field.label,
                    value: field.name
                    }
                })
            ]
        }
    }

    async getObjectTypes() {
        interface ObjectSchema {
            labels: { singular: string; plural: string }
            fullyQualifiedName: string
        }
        
        interface GetSchemasResponse {
            results: ObjectSchema[]
        }

        const defaultChoices = [
        {
            label: 'Contact',
            value: 'contact'
        },
        {
            label: 'Company',
            value: 'company'
        },
        {
            label: 'Deal',
            value: 'deal'
        },
        {
            label: 'Ticket',
            value: 'ticket'
        }
        ]
        // API Doc - https://developers.hubspot.com/docs/api/crm/crm-custom-objects#endpoint?spec=GET-/crm/v3/schemas
        try {
        const response = await this.request<GetSchemasResponse>(`${HUBSPOT_BASE_URL}/crm/v3/schemas?archived=false`, {
            method: 'GET',
            skipResponseCloning: true
        })
        const choices = response.data.results
            .map((schema) => ({
            label: `${schema.labels.plural} (Custom)`,
            value: schema.fullyQualifiedName
            }))
        return {
            choices: [...choices, ...defaultChoices]
        }
        } catch (err) {
        return {
            choices: [],
            error: {
            message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
            code: (err as HubSpotError)?.response?.status + '' ?? '500'
            }
        }
        }
    }

    async getAssociationLabel(objectType: string, toObjectType: string) {
        
        interface AssociationLabel {
            category: AssociationCategory
            typeId: number
            label: string
        }
        interface GetAssociationLabelResponse {
            results: AssociationLabel[]
        }
        
        try {
            const response = await this.request<GetAssociationLabelResponse>(
                `${HUBSPOT_BASE_URL}/crm/v4/associations/${objectType}/${toObjectType}/labels`,
                {
                method: 'GET',
                skipResponseCloning: true
                }
        )
        const choices = response?.data?.results?.map((res) => ({
            label: !res.label ? `${objectType} to ${toObjectType} (Type ${res.typeId})` : `${objectType} to ${toObjectType} ${res.label}`,
            value: `${res.category}:${res.typeId}`
        }))
        return {
            choices
        }
        } catch (err) {
        return {
            choices: [],
            error: {
            message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
            code: (err as HubSpotError)?.response?.data?.category ?? 'Unknown code'
            }
        }
        }
    }

    async search( idFieldName: string, idFieldValue: string, objectType: string, responseProperties: string[], responseSortBy: string[]) {
        enum SearchFilterOperator {
            EQ = 'EQ'
        }
        interface SearchPayload {
            filterGroups: SearchFilterGroup[]
            properties?: string[]
            sorts?: string[]
            limit?: number
            after?: number
        }
        interface SearchFilterGroup {
            filters: SearchFilter[]
        }
        interface SearchFilter {
            propertyName: string
            operator: SearchFilterOperator
            value: unknown
        }

        const searchPayload: SearchPayload = {
            filterGroups: [{
                filters: [{
                    propertyName: idFieldName,
                    operator: SearchFilterOperator.EQ,
                    value: idFieldValue
                }]
            }],
            properties: [...responseProperties],
            sorts: [...responseSortBy]
        }

        return this.request<SearchResponse>(`${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}/search`, {
            method: 'POST',
            json: {
                ...searchPayload
            }
        })
    }

    async update(idFieldName: string, recordId: string,  objectType: string, properties: { [key: string]: unknown }, ) {
        const updateURL = `${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}/${recordId}?idProperty=${idFieldName}`
        return this.request<UpsertRecordResponse>(updateURL, {
            method: 'PATCH',
            json: {
                properties: properties
            }
        })
    }

    async create(objectType: string, properties: { [key: string]: unknown }, associationLabel?: string, toRecordId?: string) {
        interface CreateAssociation {
            to: {
              id: string
            }
            types: AssociationType[]
        }
        
        let associationObject = null

        if(toRecordId && associationLabel){
            associationObject = {
                to: {
                  id: toRecordId
                },
                types: this.getAssociationType(associationLabel)
            } as CreateAssociation
        }

        return this.request<UpsertRecordResponse>(`${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}`, {
          method: 'POST',
          json: {
            properties: properties,
            associations: associationObject
          }
        })
      }

    async getRecordID( idFieldName?: string, idFieldValue?: string, objectType?: string): Promise<string | undefined> {
        
        if(!idFieldName || !idFieldValue || !objectType) return undefined

        if(idFieldName === 'hs_object_id') return idFieldValue 
        
        let searchResponse: ModifiedResponse<SearchResponse> | null = null
        searchResponse = await this.search(idFieldName, idFieldValue, objectType, [], [])   
        if (!searchResponse?.data || searchResponse?.data?.total != 1) {
            return undefined
        }
        return searchResponse.data.results[0].id
    }

    async associate(recordId: string, toRecordId: string, associationLabel: string, objectType: string, toObjectType: string) {
        const association = this.getAssociationType(associationLabel)
        const associateURL = `${HUBSPOT_BASE_URL}/crm/v4/objects/${objectType}/${recordId}/associations/${toObjectType}/${toRecordId}`
        return this.request<UpsertRecordResponse>(associateURL, {
          method: 'PUT',
          json: association
        })
    }

    getAssociationType(associationLabel?: string): AssociationType[]{
        if(!associationLabel){
            return []
        }

        const associationType = associationLabel.split(':')
        
        return [{
          associationCategory: associationType[0] as AssociationCategory,
          associationTypeId: Number(associationType[1])
        }] as AssociationType[]
    }

    async batchRequest(
        action: 'update' | 'create' | 'read', 
        objectType: string,
        data: BatchReadRequestBody | BatchRequestBody
    ) {        
        console.log(`${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}/batch/${action}`)
        const response = this.request<BatchReadResponse>(`${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}/batch/${action}`, {
            method: 'POST',
            json: data
        });

        return response
    }

    async ensureObjects(insertType: typeof INSERT_TYPES[number]['value'], idFieldName: string, objectType: string, payloads: Payload[]) {

        const requests = []

        for (let i = 0; i < payloads.length; i += BATCH_SIZE) {
            const batch = payloads.slice(i, i + BATCH_SIZE);
            requests.push(
            this.batchRequest('read', objectType, {
                properties: [idFieldName],
                idProperty: idFieldName,
                inputs: batch.map(p => { return {id: p.idFieldValue}})             
            } as BatchReadRequestBody)
            )
        }
        
        const readResponses = await Promise.all(requests);
        
        readResponses.forEach((response) => {      
            response.data.results.forEach(result => {
            const recordId = result.id
            const idFieldValue = result.properties[idFieldName] as string
            payloads.filter(payload => payload.idFieldValue == idFieldValue).forEach(payload => payload.recordID = recordId)
            })
        })

        const updateRequestBodies: BatchRequestBody[] = []
        const createRequestBodies: BatchRequestBody[] = []
        const createRequests:Promise<ModifiedResponse<BatchReadResponse>>[] = []
        const updateRequests:Promise<ModifiedResponse<BatchReadResponse>>[] = []

        const populate = (requestBodies: BatchRequestBody[], itemPayload: BatchRequestBodyItem) => {
            const currenRequestBody = requestBodies[requestBodies.length - 1]?.inputs;
            if (!currenRequestBody || currenRequestBody.length === BATCH_SIZE) {
                requestBodies.push({ inputs: [itemPayload] });
            } else {
                currenRequestBody.push(itemPayload);
            }
        };

        payloads.forEach((payload) => {
            const { stringProperties, numericProperties, booleanProperties, dateProperties } = payload
            const itemPayload: { id?: string | undefined; properties: { [key: string]: string | number | boolean | undefined } } = {
                id: payload.recordID ?? undefined,
                properties: {
                    ...stringProperties, 
                    ...numericProperties, 
                    ...booleanProperties, 
                    ...dateProperties,
                    [payload.idFieldName]: payload.idFieldValue
                } as BatchRequestBodyItem['properties']
            } as BatchRequestBodyItem
            if(['update', 'upsert'].includes(insertType) && itemPayload.id){
                populate(updateRequestBodies, itemPayload)
            }
            if(['create', 'upsert'].includes(insertType) && !itemPayload.id){
                populate(createRequestBodies, itemPayload)
            }
        })
        
        updateRequestBodies.forEach((updateRequestBody) => {
            updateRequests.push(this.batchRequest('update', objectType, updateRequestBody))
        })

        createRequestBodies.forEach((createRequestBody) => {
            createRequests.push(this.batchRequest('create', objectType, createRequestBody))
        })
        console.log(updateRequests.length)
        console.log(createRequests.length)
        
        const writeResponses = await Promise.all([...updateRequests, ...createRequests])
        
        console.log(writeResponses)
    }
}
