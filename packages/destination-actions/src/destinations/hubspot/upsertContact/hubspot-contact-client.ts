import { Payload as ContactPayload } from './generated-types'
import { RequestClient, HTTPError, DynamicFieldResponse } from '@segment/actions-core'
import { flattenObject } from '../utils'
import { HUBSPOT_BASE_URL } from '../properties'
import { TransactionContext } from '@segment/actions-core/destination-kit'

interface ContactProperties {
    company?: string | undefined
    firstname?: string | undefined
    lastname?: string | undefined
    phone?: string | undefined
    address?: string | undefined
    city?: string | undefined
    state?: string | undefined
    country?: string | undefined
    zip?: string | undefined
    email?: string | undefined
    website?: string | undefined
    lifecyclestage?: string | undefined
    [key: string]: string | undefined
}

interface ContactCreateRequestBody {
    properties: ContactProperties
}
interface ContactUpdateRequestBody {
    properties: ContactProperties
    id: string
}

interface ContactSuccessResponse {
    id: string
    properties: Record<string, string | null>
}

interface BatchContactUpdateRequestBody {
    inputs: ContactUpdateRequestBody[]
}

interface BatchContactCreateRequestBody {
    inputs: ContactCreateRequestBody[]
}

interface BatchContactReadRequestBody {
    properties: string[]
    idProperty: string
    inputs: Array<{ id: string }>
}

export interface BatchContactResponse {
    status: string
    results: ContactSuccessResponse[]
}

interface ContactsFieldsResponse {
    data: {
      results: ContactField[]
    }
}

interface ContactField {
    label: string
    name: string
    hasUniqueValue: boolean
}

const HUBSPOT_OBJECT_CONTACT_URL = `${HUBSPOT_BASE_URL}/crm/v3/objects/contacts`
const HUBSPOT_PROPERTIES_CONTACT_URL = `${HUBSPOT_BASE_URL}/crm/v3/properties/contacts`

class HubspotContactClient {
    private _request: RequestClient
  
    constructor(request: RequestClient) {
      this._request = request
    }

    async getIDTypes(): Promise<DynamicFieldResponse> {
        const contactFields: ContactsFieldsResponse = await this._request(`${HUBSPOT_PROPERTIES_CONTACT_URL}`, {
            method: 'GET',
            skipResponseCloning: true
        })
      
        return {
            choices: [
                {
                    label: 'Email',
                    value: 'email'
                },
                // hs_unique_creation_key is a unique identifier that is automatically generated by HubSpot. It is readonly so should not be included in the dynamic list
                ...contactFields.data.results
                    .filter((field: ContactField) => field.hasUniqueValue && field.name != 'hs_unique_creation_key')
                    .map((field: ContactField) => {
                        return {
                            label: field.label,
                            value: field.name
                        }
                    })
            ]
        }
    }

    async createOrUpdateBatch(createRequest: BatchContactCreateRequestBody, updateRequest: BatchContactUpdateRequestBody) {         
        if(createRequest.inputs.length>0){
            await this.batchRequest('create', createRequest)
        }
        if(updateRequest.inputs.length>0){
            const updateResponse = await this.batchRequest('update', updateRequest)
            const results = updateResponse.data.results            
            const differences: { id: string; properties: { lifecyclestage: string } }[] = []
            const differences_reset: { id: string; properties: { lifecyclestage: string } }[] = []

            results.forEach((result) => {
                const request = updateRequest.inputs.find((req) => req.id === result.id)
                
                if (request && request.properties.lifecyclestage && (result.properties.lifecyclestage!==request.properties.lifecyclestage)) {
                    differences_reset.push({
                        id: request.id,
                        properties: {
                            lifecyclestage: ''
                        }
                    })
                    differences.push({
                        id: request.id,
                        properties: {
                            lifecyclestage: request.properties.lifecyclestage
                        }
                    })
                }
            })
            // Hubspot lifecycle stage reset and update. Needed to allow lifecycle stage to be moved backwards
            if (differences.length > 0) {
                // Reset Life Cycle Stage
                await this.batchRequest('update', {inputs: differences_reset})
                // Set the new Life Cycle Stage
                await this.batchRequest('update', {inputs: differences})
            }
        }
    }

    private async batchRequest(
        endpoint: 'update' | 'create' | 'read', 
        data: (BatchContactUpdateRequestBody | BatchContactCreateRequestBody | BatchContactReadRequestBody)
    ) {        
        const response = await this._request<BatchContactResponse>(`${HUBSPOT_OBJECT_CONTACT_URL}/batch/${endpoint}`, {
            method: 'POST',
            json: data
        });
        return response
    }

    buildBatchRequest (payloads: ContactPayload[]): { updateRequest: BatchContactUpdateRequestBody, createRequest: BatchContactCreateRequestBody }{
        const updateRequest: BatchContactUpdateRequestBody = { inputs: [] }
        const createRequest: BatchContactCreateRequestBody = { inputs: [] }

        payloads.forEach((payload) => {    
            const requestPayload = {
                id: payload.canonical_id ?? undefined,
                properties: {
                  company: payload.company,
                  firstname: payload.firstname,
                  lastname: payload.lastname,
                  phone: payload.phone,
                  address: payload.address,
                  city: payload.city,
                  state: payload.state,
                  country: payload.country,
                  zip: payload.zip,
                  [payload.identifier_type as string]: payload.email,
                  website: payload.website,
                  lifecyclestage: payload.lifecyclestage?.toLowerCase() ?? undefined,
                  ...flattenObject(payload.properties)
                } as ContactProperties
            }
            if(requestPayload.id){
                delete requestPayload?.properties?.email
                updateRequest.inputs.push(requestPayload as ContactUpdateRequestBody)
            } else {
                createRequest.inputs.push(requestPayload as ContactCreateRequestBody)
            }
        })

        return { updateRequest, createRequest }
    }

    async addCononicalIDsToBatchPayloads(payloads: ContactPayload[]): Promise<ContactPayload[]>{
        
        payloads.forEach(payload => payload.identifier_type = payload.identifier_type ?? 'email')

        const unique_identifier_types: string[] = Array.from(new Set(payloads.map(payload => payload.identifier_type as string))) ?? [];

        const requestPayloads: BatchContactReadRequestBody[] = []
        unique_identifier_types.forEach(identifier_type => {
            const requestPayload: BatchContactReadRequestBody = {
                properties: [...new Set([...['email', 'lifecyclestage'], ...[identifier_type]])],
                idProperty: identifier_type,
                inputs: payloads
                    .filter(payload => payload.identifier_type === identifier_type)
                    .map(payload => { return {id: payload.email}})             
            }
            requestPayloads.push(requestPayload)
        }) 

        const promises = requestPayloads.map(payload => this.batchRequest('read', payload));

        const responses = await Promise.all(promises);

        unique_identifier_types.forEach((identifier_type, index) => {
            responses[index].data.results.forEach((contactResponse) => {
                const canonical_id = contactResponse.id 
                const identifier_value = contactResponse.properties[identifier_type] as string
                payloads.filter(payload => payload.email == identifier_value).forEach(payload => payload.canonical_id = canonical_id);
            })
        });        
        return payloads
    }

    private buildSingleContactRequestBody(payload: ContactPayload): ContactProperties {
        return {
            company: payload.company,
            firstname: payload.firstname,
            lastname: payload.lastname,
            phone: payload.phone,
            address: payload.address,
            city: payload.city,
            state: payload.state,
            country: payload.country,
            zip: payload.zip,
            [(payload.identifier_type as string) ?? 'email']: payload.email,
            website: payload.website,
            lifecyclestage: payload.lifecyclestage?.toLowerCase(),
            ...flattenObject(payload.properties)
          } as ContactProperties
    }

    private async update(properties: ContactProperties, identifierValue: string, identifier_type: string) {
        return await this._request<ContactSuccessResponse>(
          `${HUBSPOT_OBJECT_CONTACT_URL}/${identifierValue}?idProperty=${identifier_type}`,
          {
            method: 'PATCH',
            json: {
              properties: properties
            }
          }
        )
    }

    private async create(properties: ContactProperties) {
        return await this._request<ContactSuccessResponse>(
            `${HUBSPOT_OBJECT_CONTACT_URL}`, {
            method: 'POST',
            json: {
                properties
            }
        })
    }

    async createOrUpdate(payload: ContactPayload, transactionContext: TransactionContext | undefined) { 
        const singleContactRequestBody = this.buildSingleContactRequestBody(payload)
        // An attempt is made to update contact with given properties. If HubSpot returns 404 indicating
        // the contact is not found, an attempt will be made to create contact with the given properties
        try {
            const { email: identifierValue, identifier_type = 'email' } = payload
            const response = await this.update(singleContactRequestBody, identifierValue, identifier_type)
    
            // cache contact_id for it to be available for company action
            transactionContext?.setTransaction('contact_id', response.data.id)
    
            // HubSpot returns the updated lifecylestage(LCS) as part of the response.
            // If the stage we are trying to set is backward than the current stage, it retains the current stage
            // and updates the timestamp. For determining if reset is required or not, we can compare
            // the stage returned in response with the desired stage . If they are not the same, reset
            // and update. More details - https://knowledge.hubspot.com/contacts/use-lifecycle-stages
            if (payload.lifecyclestage) {
                const currentLCS = response.data.properties['lifecyclestage']
                const hasLCSChanged = currentLCS === payload.lifecyclestage.toLowerCase()
                if (hasLCSChanged) return response
                // reset lifecycle stage
                await this.update({ lifecyclestage: ''}, identifierValue, identifier_type)
                // update contact again with new lifecycle stage
                return this.update(singleContactRequestBody, identifierValue, identifier_type)
            }
            return response
        } catch (ex) {
            if ((ex as HTTPError)?.response?.status == 404) {
            const result = await this.create(singleContactRequestBody)
            // cache contact_id for it to be available for company action
            transactionContext?.setTransaction('contact_id', result.data.id)
            return result
            }
            throw ex
        }
    }
}
  
export default HubspotContactClient
  